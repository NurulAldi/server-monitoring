// Model untuk data Alert
// Schema MongoDB untuk menyimpan notifikasi alert dan status penyelesaiannya

const mongoose = require('mongoose');
const { STATUS_OK, STATUS_WARNING, STATUS_CRITICAL, ALERT_BARU, ALERT_DIACKNOWLEDGE, ALERT_DISOLVED } = require('../utilitas/konstanta');

/**
 * DESKRIPSI: Schema untuk menyimpan data alert/notifikasi monitoring server
 *
 * TUJUAN: Menyimpan alert yang dihasilkan otomatis berdasarkan kondisi server
 * untuk tracking masalah, escalation, dan audit trail penyelesaian.
 *
 * STRUKTUR DATA:
 * - Referensi server dan metrics yang memicu alert
 * - Jenis alert dan severity level
 * - Status penyelesaian dan acknowledgment
 * - Metadata: timestamps, assigned user, resolusi notes
 *
 * ALASAN DESIGN:
 * - Tracking lengkap lifecycle alert dari trigger sampai resolusi
 * - Escalation berdasarkan severity dan durasi unresolved
 * - Audit trail untuk compliance dan improvement
 * - Integration dengan notification system (email, webhook)
 * - TTL index untuk cleanup alert lama yang sudah resolved
 */
const alertSchema = new mongoose.Schema({
  // Referensi ke server yang mengalami masalah
  serverId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Server',
    required: [true, 'Server ID wajib diisi'],
    index: true
  },

  // Referensi ke metrics yang memicu alert (opsional)
  metrikId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Metrik'
  },

  // Informasi dasar alert
  judul: {
    type: String,
    required: [true, 'Judul alert wajib diisi'],
    trim: true,
    maxlength: [200, 'Judul alert maksimal 200 karakter']
  },

  deskripsi: {
    type: String,
    required: [true, 'Deskripsi alert wajib diisi'],
    trim: true,
    maxlength: [1000, 'Deskripsi alert maksimal 1000 karakter']
  },

  jenisAlert: {
    type: String,
    required: [true, 'Jenis alert wajib diisi'],
    enum: {
      values: ['cpu_high', 'memory_high', 'disk_high', 'network_issue', 'service_down', 'custom'],
      message: 'Jenis alert tidak valid'
    }
  },

  // Severity level alert
  severity: {
    type: String,
    required: [true, 'Severity alert wajib diisi'],
    enum: {
      values: [STATUS_WARNING, STATUS_CRITICAL],
      message: 'Severity alert tidak valid'
    },
    default: STATUS_WARNING
  },

  // Status alert lifecycle
  statusAlert: {
    type: String,
    enum: {
      values: [ALERT_BARU, ALERT_DIACKNOWLEDGE, ALERT_DISOLVED],
      message: 'Status alert tidak valid'
    },
    default: ALERT_BARU,
    index: true
  },

  // Kondisi yang memicu alert
  kondisiPemicu: {
    metric: {
      type: String,
      enum: ['cpu', 'memori', 'disk', 'jaringan', 'service'],
      required: [true, 'Metric pemicu wajib diisi']
    },
    nilaiAktual: {
      type: Number,
      required: [true, 'Nilai aktual wajib diisi']
    },
    threshold: {
      type: Number,
      required: [true, 'Threshold wajib diisi']
    },
    operator: {
      type: String,
      enum: ['>', '>=', '<', '<=', '==', '!='],
      default: '>'
    },
    unit: {
      type: String,
      trim: true,
      default: '%'
    }
  },

  // Timestamps untuk tracking lifecycle
  timestampPemicu: {
    type: Date,
    default: Date.now,
    required: true,
    index: true
  },

  timestampAcknowledgment: {
    type: Date
  },

  timestampResolusi: {
    type: Date
  },

  // Assignment dan ownership
  assignedKe: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Pengguna'
  },

  acknowledgedOleh: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Pengguna'
  },

  disolvedOleh: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Pengguna'
  },

  // Notes dan komentar
  catatanAcknowledgment: {
    type: String,
    trim: true,
    maxlength: [500, 'Catatan acknowledgment maksimal 500 karakter']
  },

  catatanResolusi: {
    type: String,
    trim: true,
    maxlength: [1000, 'Catatan resolusi maksimal 1000 karakter']
  },

  // Escalation tracking
  escalationLevel: {
    type: Number,
    min: [0, 'Escalation level minimal 0'],
    default: 0
  },

  timestampEscalationTerakhir: {
    type: Date
  },

  // Notification tracking
  notifikasiTerkirim: [{
    metode: {
      type: String,
      enum: ['email', 'webhook', 'sms', 'slack'],
      required: true
    },
    timestamp: {
      type: Date,
      default: Date.now
    },
    status: {
      type: String,
      enum: ['berhasil', 'gagal'],
      default: 'berhasil'
    },
    errorMessage: {
      type: String,
      trim: true
    }
  }],

  // Metadata alert
  metadataAlert: {
    ruleId: {
      type: String,
      trim: true
    },
    autoGenerated: {
      type: Boolean,
      default: true
    },
    source: {
      type: String,
      enum: ['monitoring_agent', 'manual', 'api', 'scheduled_check'],
      default: 'monitoring_agent'
    },
    tags: [{
      type: String,
      trim: true,
      lowercase: true
    }],
    customData: {
      type: mongoose.Schema.Types.Mixed
    }
  }

}, {
  timestamps: true,
  collection: 'alert'
});

/**
 * INDEXING STRATEGI
 *
 * 1. Compound index untuk query alert berdasarkan server dan status
 * 2. Index untuk query berdasarkan severity dan timestamp
 * 3. TTL index untuk cleanup alert resolved lama (90 hari)
 */
alertSchema.index({ serverId: 1, statusAlert: 1 });
alertSchema.index({ severity: 1, timestampPemicu: -1 });
alertSchema.index({ assignedKe: 1 });
alertSchema.index({ timestampPemicu: 1 }, { expireAfterSeconds: 90 * 24 * 60 * 60 }); // 90 hari untuk resolved alerts

/**
 * VIRTUALS
 *
 * Menambahkan computed properties untuk kemudahan akses data
 */
alertSchema.virtual('durasiUnresolved').get(function() {
  const endTime = this.timestampResolusi || this.timestampAcknowledgment || Date.now();
  return endTime - this.timestampPemicu.getTime();
});

alertSchema.virtual('durasiAcknowledgment').get(function() {
  if (!this.timestampAcknowledgment) return null;
  return this.timestampAcknowledgment.getTime() - this.timestampPemicu.getTime();
});

alertSchema.virtual('durasiResolusi').get(function() {
  if (!this.timestampResolusi) return null;
  const startTime = this.timestampAcknowledgment || this.timestampPemicu;
  return this.timestampResolusi.getTime() - startTime.getTime();
});

alertSchema.virtual('ringkasanAlert').get(function() {
  return {
    id: this._id,
    judul: this.judul,
    severity: this.severity,
    status: this.statusAlert,
    serverId: this.serverId,
    durasi: this.durasiUnresolved,
    assigned: this.assignedKe,
    escalated: this.escalationLevel > 0
  };
});

/**
 * INSTANCE METHODS
 *
 * Method untuk operasi pada instance alert tertentu
 */

/**
 * Method untuk acknowledge alert
 */
alertSchema.methods.acknowledge = function(userId, catatan = '') {
  if (this.statusAlert !== ALERT_BARU) {
    throw new Error('Alert sudah di-acknowledge atau di-resolve');
  }

  this.statusAlert = ALERT_DIACKNOWLEDGE;
  this.timestampAcknowledgment = new Date();
  this.acknowledgedOleh = userId;
  this.catatanAcknowledgment = catatan;

  return this.save();
};

/**
 * Method untuk resolve alert
 */
alertSchema.methods.resolve = function(userId, catatan = '') {
  this.statusAlert = ALERT_DISOLVED;
  this.timestampResolusi = new Date();
  this.disolvedOleh = userId;
  this.catatanResolusi = catatan;

  return this.save();
};

/**
 * Method untuk escalate alert
 */
alertSchema.methods.escalate = function() {
  this.escalationLevel += 1;
  this.timestampEscalationTerakhir = new Date();

  return this.save();
};

/**
 * Method untuk assign alert ke user
 */
alertSchema.methods.assignKe = function(userId) {
  this.assignedKe = userId;
  return this.save();
};

/**
 * Method untuk menambah notifikasi terkirim
 */
alertSchema.methods.tambahNotifikasi = function(metode, status = 'berhasil', errorMessage = '') {
  this.notifikasiTerkirim.push({
    metode,
    status,
    errorMessage,
    timestamp: new Date()
  });

  return this.save();
};

/**
 * Method untuk format alert untuk display
 */
alertSchema.methods.formatUntukDisplay = function() {
  return {
    id: this._id,
    judul: this.judul,
    deskripsi: this.deskripsi,
    jenisAlert: this.jenisAlert,
    severity: this.severity,
    status: this.statusAlert,
    kondisi: {
      metric: this.kondisiPemicu.metric,
      nilai: `${this.kondisiPemicu.nilaiAktual}${this.kondisiPemicu.unit}`,
      threshold: `${this.kondisiPemicu.operator}${this.kondisiPemicu.threshold}${this.kondisiPemicu.unit}`
    },
    timestamps: {
      pemicu: this.timestampPemicu,
      acknowledgment: this.timestampAcknowledgment,
      resolusi: this.timestampResolusi
    },
    durasi: {
      unresolved: this.durasiUnresolved,
      acknowledgment: this.durasiAcknowledgment,
      resolusi: this.durasiResolusi
    },
    assignment: {
      assignedKe: this.assignedKe,
      acknowledgedOleh: this.acknowledgedOleh,
      disolvedOleh: this.disolvedOleh
    },
    catatan: {
      acknowledgment: this.catatanAcknowledgment,
      resolusi: this.catatanResolusi
    },
    escalation: {
      level: this.escalationLevel,
      terakhir: this.timestampEscalationTerakhir
    },
    notifikasi: this.notifikasiTerkirim,
    metadata: this.metadataAlert
  };
};

/**
 * STATIC METHODS
 *
 * Method untuk query dan agregasi data alert
 */

/**
 * Method untuk mendapatkan alert aktif (belum resolve)
 */
alertSchema.statics.dapatkanAlertAktif = function(serverId = null) {
  const query = {
    statusAlert: { $ne: ALERT_DISOLVED }
  };

  if (serverId) {
    query.serverId = serverId;
  }

  return this.find(query)
    .sort({ severity: -1, timestampPemicu: -1 })
    .populate('serverId', 'nama jenisServer')
    .populate('assignedKe', 'nama email')
    .populate('acknowledgedOleh', 'nama email');
};

/**
 * Method untuk mendapatkan alert berdasarkan severity
 */
alertSchema.statics.dapatkanAlertBySeverity = function(severity, limit = 50) {
  return this.find({ severity })
    .sort({ timestampPemicu: -1 })
    .limit(limit)
    .populate('serverId', 'nama jenisServer');
};

/**
 * Method untuk mendapatkan statistik alert
 */
alertSchema.statics.dapatkanStatistikAlert = function(hariTerakhir = 30) {
  const startDate = new Date(Date.now() - (hariTerakhir * 24 * 60 * 60 * 1000));

  return this.aggregate([
    {
      $match: {
        timestampPemicu: { $gte: startDate }
      }
    },
    {
      $group: {
        _id: null,
        totalAlert: { $sum: 1 },
        alertBaru: {
          $sum: { $cond: [{ $eq: ['$statusAlert', ALERT_BARU] }, 1, 0] }
        },
        alertAcknowledged: {
          $sum: { $cond: [{ $eq: ['$statusAlert', ALERT_DIACKNOWLEDGE] }, 1, 0] }
        },
        alertResolved: {
          $sum: { $cond: [{ $eq: ['$statusAlert', ALERT_DISOLVED] }, 1, 0] }
        },
        bySeverity: {
          $push: '$severity'
        },
        byType: {
          $push: '$jenisAlert'
        },
        rataRataResolusiMs: {
          $avg: {
            $cond: [
              { $ne: ['$timestampResolusi', null] },
              { $subtract: ['$timestampResolusi', '$timestampPemicu'] },
              null
            ]
          }
        }
      }
    }
  ]);
};

/**
 * Method untuk mendeteksi alert yang perlu escalation
 */
alertSchema.statics.dapatkanAlertPerluEscalation = function(jamTanpaAcknowledgment = 2) {
  const thresholdTime = new Date(Date.now() - (jamTanpaAcknowledgment * 60 * 60 * 1000));

  return this.find({
    statusAlert: ALERT_BARU,
    timestampPemicu: { $lt: thresholdTime },
    severity: STATUS_CRITICAL
  })
  .populate('serverId', 'nama jenisServer');
};

/**
 * MIDDLEWARE
 *
 * Hook untuk preprocessing
 */

/**
 * Pre-save middleware untuk validasi data
 */
alertSchema.pre('save', function(next) {
  // Validasi timestamp resolusi harus setelah acknowledgment
  if (this.timestampResolusi && this.timestampAcknowledgment) {
    if (this.timestampResolusi < this.timestampAcknowledgment) {
      return next(new Error('Timestamp resolusi harus setelah acknowledgment'));
    }
  }

  // Validasi acknowledgment timestamp harus setelah pemicu
  if (this.timestampAcknowledgment && this.timestampAcknowledgment < this.timestampPemicu) {
    return next(new Error('Timestamp acknowledgment harus setelah pemicu'));
  }

  next();
});

/**
 * Post-save middleware untuk logging
 */
alertSchema.post('save', function(doc) {
  console.log(`ðŸ“Š Alert ${doc.judul} status berubah ke ${doc.statusAlert}`);
});

// Buat model dari schema
const Alert = mongoose.model('Alert', alertSchema);

module.exports = Alert;